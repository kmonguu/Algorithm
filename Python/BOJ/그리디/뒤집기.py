# 0과 1로만 이루어진 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다.
# 0은 1로, 1은 0으로 뒤집을 때 뒤집는 행동의 최소 횟수를 출력하는 문제


# 풀이
# 예를 들어, 0001100 일 때, 연속된 4번 째와 5번 째의 1을 동시에 0으로 바꿔주면 1번만에 모두 같은 숫자로 만들 수 있다.
# 001001이라는 문자열이 있다면, 3번 째의 1을 0으로 뒤집고, 6번 째의 1을 0으로 뒤집으면 2번 만에 모두 같은 숫자로 만들 수 있다.

# 문자열이 0에서 1로 또는 1에서 0으로 바뀔 때를 기준으로 뒤집는 횟수가 바뀐다는 점을 이용하여 문제를 풀었다.

# 코드
# arr이라는 빈 리스트를 만들어놓고 연속으로 같은 숫자가 나올 때를 제외하여 arr에 담아준다.
# 최종적으로 arr에 담긴 요소들의 수를 세어 2를 나누어 뒤집는 횟수를 구한다.

S = list(input())
arr = []

if len(S) == S.count('1') or len(S) == S.count('0'):      # 문자열 S의 길이와 1 또는 0의 출현 횟수가 같다면 해당 문자열은 전부 1이거나 0으로 이루어져 있으므로 뒤집기가 필요없다.
  arr = []                                                # 그러므로 arr리스트를 빈 리스트로 초기화해준다.

while S:                                                  # S 문자열 리스트가 비어있지 않는 동안
  if arr and S[0] == arr[-1]:                             # S[0]와 arr[-1]이 같다면 연속하여 같은 숫자가 나왔다는 의미이므로
    S.pop(0)                                              # 숫자의 연속된 출현을 막기 위해 pop(0)해준다.

  else:                               
    arr.append(S.pop(0))                                  # S[0]을 arr[-1]에 넣어줌으로 S 문자열에서 연속하게 같은 숫자가 나온 것을 제외하여 담을 수 있다.

print(len(arr)//2)                                        # 2를 나누어 뒤집기 횟수를 구할 수 있다.




# 다른 방법 : pop(0)연산을 할 때 시간복잡도가 커지기 때문에 deque의 popleft연산을 해주는 게 좋음
# pop(0)을 하는 방법 대신 for문을 사용하여 S 문자열 배열을 순회하여 연속된 같은 수를 제외하고 arr 배열에 넣어준다.

S = list(input())

arr = [S[0]]
for i in range(1, len(S)):        # S 순회
  if arr[-1] != S[i]:             # S의 마지막 요소랑 S[i]랑 다르면 즉, 구간이 바뀌는 지점이면
    arr.append(S[i])              # append

print(len(arr)//2)
